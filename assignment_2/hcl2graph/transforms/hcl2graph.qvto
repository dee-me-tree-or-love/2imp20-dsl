modeltype HCL uses 'http://www.example.org/metamodelHCL';
modeltype Graph uses 'http://dsldesign.tue.nl/graph';

transformation hcl2graph(in hcl : HCL, out Graph);

helper makeNode(l: String, s: Graph::Shape) : Graph::Node {
	return object Graph::Node {
		label := l; 
		shape := s;
	};
}

helper makeBoxNode(l: String) : Graph::Node {
	return makeNode(l, Graph::Shape::BOX);
}

helper makeEdge(t: Graph::Node, s: Graph::Style) : Graph::Edge {
	return object Graph::Edge {
		target := t;
		style := s;
	};
}

helper Graph::Node::target2solidedge() : Graph::Edge {
	return makeEdge(self, Graph::Style::SOLID);
}

helper Graph::Node::target2dashededge() : Graph::Edge {
	return makeEdge(self, Graph::Style::DASHED);
}

// Property to contain the immediate children of the Node.
intermediate property Graph::Node::children : Collection(Graph::Node);

main() {
	// TODO: pass the nodes down the method here??? or define them as globa somehow??
	hcl.rootObjects()[HCL::Model] -> map model2graph();
}

// MODEL TRANSFORMATIONS
// ~~~~~~~~~~~~~~~~~~~~~

mapping HCL::Model::model2graph() : Graph::Graph {
	var processingTreeRoot : Graph::Node = self.makeProcessingSpeedTree();
	var processingSpeeds : Collection(Graph::Node) := processingTreeRoot.children;
	var displayTreeRoot : Graph::Node := self.makeDisplayDiagonalTree();
	var displayDiagonals : Collection(Graph::Node) := displayTreeRoot.children;
	// TODO: define root level mappings
	var roots : List(Graph::Node) := List {processingTreeRoot, displayTreeRoot};
	nodes := roots 
		-> union(processingSpeeds -> asList())
		-> union(displayDiagonals -> asList())
		-> asList();
}

// Critical Property Subgraphs
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: (tech debt) overcome duplication with Display.
helper HCL::Model::makeProcessingSpeedTree() : Graph::Node {
	var root := makeBoxNode('CPU');
	var children : Set(Graph::Node) := self.uniqueProcessingSpeeds();
	var edges : Set(Graph::Edge) := children -> target2solidedge() -> asSet();
	root.outEdges := edges -> asOrderedSet();
	root.children := children;
	return root;
}

query HCL::Model::uniqueProcessingSpeeds() : Set(Graph::Node) {
	var props : Collection(HCL::Processing) := self.computers -> collect(c|c.processing());
	var speeds: Collection(HCL::SpeedProperty) := props -> collect(p | p -> speed());
	var uniqueSpeedLabels : Set(String) = speeds -> nodeLabel() -> asSet();
	return uniqueSpeedLabels -> collect(l|makeBoxNode(l)) -> asSet();
}

query HCL::Computer::processing() : Collection(HCL::Processing) {
	return self.components[HCL::Processing];
}

query HCL::Processing::speed() : Collection(HCL::SpeedProperty) {
	return self.properties[HCL::SpeedProperty];
}

query HCL::SpeedProperty::nodeLabel() : String {
	return self.speed.toString() + " " + self.unit;
}

// TODO: (tech debt) overcome duplication with CPU.
helper HCL::Model::makeDisplayDiagonalTree() : Graph::Node {
	var root := makeBoxNode('Display');
	var children : Set(Graph::Node) := self.uniqueDisplayDiagonals();
	var edges : Set(Graph::Edge) := children -> target2solidedge() -> asSet();
	root.outEdges := edges -> asOrderedSet();
	root.children := children;
	return root;
}

query HCL::Model::uniqueDisplayDiagonals() : Set(Graph::Node) {
	var props : Collection(HCL::Display) := self.computers -> collect(c|c.display());
	var diagonals : Collection(HCL::DiagonalProperty) := props -> collect(p | p -> diagonal());
	var uniqueDiagonalLabels : Set(String) = diagonals -> nodeLabel() -> asSet();
	return uniqueDiagonalLabels -> collect(l|makeBoxNode(l)) -> asSet();
}

query HCL::Computer::display() : Collection(HCL::Display) {
	return self.components[HCL::Display];
}

query HCL::Display::diagonal() : Collection(HCL::DiagonalProperty) {
	return self.properties[HCL::DiagonalProperty];
}

query HCL::DiagonalProperty::nodeLabel() : String {
	return self.size.toString() + " " + self.unit;
}

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^


mapping HCL::Computer::computer2node() : Graph::Node {
	label := self.label;
	shape := Graph::Shape::BOX;
}

mapping HCL::Component::component2node() : Graph::Node {
	label := self.label;
	shape := Graph::Shape::BOX;
}


mapping HCL::Computer::computer2subgraph(processingNode : Graph::Node, displayNode : Graph::Node) : Graph::Graph {
	var computer : Graph::Node := self.map computer2node();
	
}

// UTILITY TRANSFORMATIONS
// ~~~~~~~~~~~~~~~~~~~~~~~

mapping Graph::Node::node2solidedge() : Graph::Edge {
	target := self;
	style := Graph::Style::SOLID;
}

mapping Graph::Node::node2dashededge() : Graph::Edge {
	target := self;
	style := Graph::Style::DASHED;
}


// TODO: define all lower level mappings
//	resources:
//		1. https://wiki.eclipse.org/images/e/ee/QVTO_EclipseCon_2009_Presentation.pdf
//	general idea:
//		1. define transformation per each level
//		2. define edges
//	tips:
//		1. consider using helpers
//		2. consider queries and the rest
// TODO: restructure the model to be easier to process for conversion