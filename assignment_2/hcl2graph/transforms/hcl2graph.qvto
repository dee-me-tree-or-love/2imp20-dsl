modeltype HCL uses 'http://www.example.org/metamodelHCL';
modeltype Graph uses 'http://dsldesign.tue.nl/graph';

transformation hcl2graph(in hcl : HCL, out Graph);

helper makeNode(l: String) : Graph::Node {
	return object Graph::Node {label := l};
}

helper makeEdge(t: Graph::Node, s: Graph::Style) : Graph::Edge {
	return object Graph::Edge {
		target := t;
		style := s;
	};
}

helper Graph::Node::target2solidedge() : Graph::Edge {
	return makeEdge(self, Graph::Style::SOLID);
}

helper Graph::Node::target2dashededge() : Graph::Edge {
	return makeEdge(self, Graph::Style::DASHED);
}

// Property to contain the immediate children of the Node.
intermediate property Graph::Node::children : Collection(Graph::Node);

main() {
	// TODO: pass the nodes down the method here??? or define them as globa somehow??
	hcl.rootObjects()[HCL::Model] -> map model2graph();
}

// MODEL TRANSFORMATIONS
// ~~~~~~~~~~~~~~~~~~~~~

mapping HCL::Model::model2graph() : Graph::Graph {
	var processingTreeRoot : Graph::Node = self.makeProcessingSpeedTree();
	var processingSpeeds : Collection(Graph::Node) := processingTreeRoot.children;
	var displayTreeRoot : Graph::Node := makeNode('Display');
	var displayDiagonals : Collection(Graph::Node) := displayTreeRoot.children;
	// TODO: define root level mappings
	
}

// Critical Property Subgraphs
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~

// TODO: (tech debt) overcome duplication with Display.
helper HCL::Model::makeProcessingSpeedTree() : Graph::Node {
	var root := makeNode('CPU');
	var properties : Set(HCL::SpeedProperty) := self.processingSpeeds() -> asSet();
	var children : Set(Graph::Node) := properties -> map speed2node() -> asSet();
	var edges : Set(Graph::Edge) := children -> target2solidedge() -> asSet();
	root.outEdges := edges -> asOrderedSet();
	root.children := children;
	return root;
}

query HCL::Model::processingSpeeds() : Collection(HCL::SpeedProperty) {
	var processingProperties : Collection(HCL::Processing) := self.computers -> collect(c|c.processing());
	return processingProperties -> collect(p | p -> speed());
}

query HCL::Computer::processing() : Collection(HCL::Processing) {
	return self.components[HCL::Processing];
}

query HCL::Processing::speed() : Collection(HCL::SpeedProperty) {
	return self.properties[HCL::SpeedProperty];
}

mapping HCL::SpeedProperty::speed2node() : Graph::Node {
	label := self.speed.toString() + " " + self.unit;
	shape := Graph::Shape::BOX;
}

// TODO: (tech debt) overcome duplication with CPU.
helper HCL::Model::makeDisplayDiagonalTree() : Graph::Node {
	var root := makeNode('Display');
	var properties : Set(HCL::DiagonalProperty) := self.displayDiagonals() -> asSet();
	var children : Set(Graph::Node) := properties -> map diagonal2node() -> asSet();
	var edges : Set(Graph::Edge) := children -> target2solidedge() -> asSet();
	root.outEdges := edges -> asOrderedSet();
	root.children := children;
	return root;
}

query HCL::Model::displayDiagonals() : Collection(HCL::DiagonalProperty) {
	var props : Collection(HCL::Display) := self.computers -> collect(c|c.display());
	return props -> collect(p | p -> diagonal());
}

query HCL::Computer::display() : Collection(HCL::Display) {
	return self.components[HCL::Display];
}

query HCL::Display::diagonal() : Collection(HCL::DiagonalProperty) {
	return self.properties[HCL::DiagonalProperty];
}

mapping HCL::DiagonalProperty::diagonal2node() : Graph::Node {
	label := self.size.toString() + " " + self.unit;
	shape := Graph::Shape::BOX;
}

// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^



mapping HCL::Computer::computer2node() : Graph::Node {
	label := self.label;
	shape := Graph::Shape::BOX;
}

mapping HCL::Component::component2node() : Graph::Node {
	label := self.label;
	shape := Graph::Shape::BOX;
}


mapping HCL::Computer::computer2subgraph(processingNode : Graph::Node, displayNode : Graph::Node) : Graph::Graph {
	var computer : Graph::Node := self.map computer2node();
	
}

// UTILITY TRANSFORMATIONS
// ~~~~~~~~~~~~~~~~~~~~~~~

mapping Graph::Node::node2solidedge() : Graph::Edge {
	target := self;
	style := Graph::Style::SOLID;
}

mapping Graph::Node::node2dashededge() : Graph::Edge {
	target := self;
	style := Graph::Style::DASHED;
}


// TODO: define all lower level mappings
//	resources:
//		1. https://wiki.eclipse.org/images/e/ee/QVTO_EclipseCon_2009_Presentation.pdf
//	general idea:
//		1. define transformation per each level
//		2. define edges
//	tips:
//		1. consider using helpers
//		2. consider queries and the rest
// TODO: restructure the model to be easier to process for conversion